{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LibrOpen","text":"<p>Empowering Open-Source Developers to Monetize and Expand Their Reach</p> <p>LibrOpen is a groundbreaking platform designed to bridge the gap between open-source development and sustainable funding. By offering an accessible and user-friendly interface, LibrOpen empowers developers to monetize their projects while showcasing their work to a wider audience.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#developer-friendly-release-management","title":"\ud83d\udee0 Developer-Friendly Release Management","text":"<ul> <li>Simplify the process of deploying and distributing your project releases.</li> <li>Manage updates, documentation, and downloads from one centralized hub.</li> </ul>"},{"location":"#a-global-open-source-library","title":"\ud83c\udf0d A Global Open-Source Library","text":"<ul> <li>Showcase your open-source projects to a diverse, global audience.</li> <li>Make it easy for the public to explore, support, and benefit from your contributions.</li> </ul>"},{"location":"#sponsorship-opportunities","title":"\ud83e\udd1d Sponsorship Opportunities","text":"<ul> <li>Attract sponsors who believe in your vision and want to back your projects.</li> <li>Build sustainable funding streams through partnerships and recurring contributions.</li> </ul>"},{"location":"#why-libropen","title":"Why LibrOpen?","text":"<p>Open-source development has revolutionized technology, but it often leaves developers struggling to secure funding for their efforts. LibrOpen addresses this challenge by:</p> <ul> <li>Democratizing Access: Making open-source software accessible to the general public.</li> <li>Sustainable Monetization: Providing tools for developers to generate income from their hard work.</li> <li>Community Building: Connecting developers, sponsors, and users in one vibrant ecosystem.</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<ol> <li>For Developers:</li> <li>Create an account and upload your projects.</li> <li> <p>Deploy your releases and start receiving support from sponsors and the community.</p> </li> <li> <p>For Sponsors:</p> </li> <li>Browse the project library and discover innovative open-source tools.</li> <li> <p>Support the projects you believe in through flexible sponsorship plans.</p> </li> <li> <p>For the Public:</p> </li> <li>Explore our library of open-source projects.</li> <li>Download, use, and support the tools that make a difference in your life.</li> </ol>"},{"location":"#join-the-movement","title":"Join the Movement","text":"<p>LibrOpen is more than a platform; it\u2019s a community-driven mission to ensure that open-source developers can thrive while continuing to create groundbreaking tools and technologies.</p> <p>Together, let\u2019s shape the future of open-source innovation.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed information on how to use LibrOpen, check out our infrastructure documentation, our frontend documentation, and our backend documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We\u2019re open to contributions! If you\u2019re a developer, designer, or enthusiast, check out our CONTRIBUTING.md to learn how you can get involved.</p>"},{"location":"CONTRIBUTING/","title":"Contribution Guide","text":"<p>This document outlines the coding standards and practices for contributions to the project. Note that the backend and frontend have distinct standards due to the different stacks being used.</p>"},{"location":"CONTRIBUTING/#code-standards","title":"Code Standards","text":""},{"location":"CONTRIBUTING/#backend","title":"Backend","text":"<p>We follow the predefined standards set by AdonisJS:</p> <ul> <li>File and Folder Naming: Use <code>snake_case</code>.</li> <li>Architecture: Stick to the default structure provided by AdonisJS. Use AdonisJS commands for consistency: AdonisJS Commands.</li> <li>Line Length: Maximum of 120 characters per line.</li> <li>Quotes: Use double quotes.</li> <li>Import Organization:</li> <li>Adonis package imports</li> <li>Internal file imports</li> <li>External packages</li> </ul> <p>Example:   <pre><code>import { HttpContext } from \"@adonis/core\";\nimport UserModel from \"#models/user\";\nimport lodash from \"lodash\";\n</code></pre></p> <ul> <li> <p>Responses in Controllers: Use AdonisJS responses for final returns or errors (e.g., <code>response.ok</code>, <code>response.badRequest</code>, <code>response.created</code>).</p> </li> <li> <p>Validators: Prioritize validators for handling request data.</p> </li> <li> <p>Endpoint Naming: Follow RESTful API naming conventions: Resource Naming.</p> </li> <li> <p>Testing: Create a folder per controller, and a file per endpoint. For example, <code>Project/create</code> tests the <code>createProject</code> request in the <code>Project</code> controller.</p> </li> <li> <p>New Packages: Verify compatibility with AdonisJS 6 before installation: AdonisJS Packages.</p> </li> <li> <p>Shared Types: Centralize shared types in the root project\u2019s shared library for cross-compatibility between frontend and backend. For example, create a type for the <code>User</code> controller inspired by its model in the shared library for frontend access.</p> </li> </ul>"},{"location":"CONTRIBUTING/#frontend","title":"Frontend","text":"<p>We adhere to Next.js standards:</p> <ul> <li>Component and File Naming:</li> <li>Use <code>PascalCase</code> for function components, Storybook files, and style files (<code>.components</code>, <code>.storybook</code>, <code>.style.tsx</code>).</li> <li>Use <code>camelCase</code> for other TypeScript files.</li> <li>Quotes: Use double quotes.</li> <li>Import Organization:</li> <li>React package imports</li> <li>Internal file imports</li> <li>External packages</li> </ul> <p>Example:   <pre><code>import React from \"react\";\nimport Button from \"@design-system/button\";\nimport lodash from \"lodash\";\n</code></pre></p> <ul> <li> <p>Design System: General components, text, and colors are defined in <code>libs/ui</code>.</p> </li> <li> <p>Types: General types are defined in <code>libs/types</code>.</p> </li> <li> <p>Constants: Use <code>libs/endpoint</code> for constants (e.g., images, endpoint names).</p> </li> <li>Component Categorization:</li> <li>Determine a component\u2019s complexity (design and/or logic) and its reusability.</li> <li>Avoid unnecessary code duplication.</li> <li>Domain Folder: Store components specific to a page and used only on that page.</li> <li>Multi-step Forms: Separate each step into its own component.</li> <li>Sub-components: Limit to two sub-function components within a file.</li> <li>CSS:</li> <li>Use the design system for styles, defined in code and on Figma.</li> <li>Ensure component flexibility (e.g., components should default to full-width).</li> <li>Storybook: Create Storybook files showcasing all possible states/variants of general components, including interactions where applicable.</li> <li>CSS Utilities:</li> <li>Use <code>styled</code> for elements with variants or dynamic styles.</li> <li>Use <code>css</code> for static designs.</li> <li>Assets:</li> <li>Store PNG images in the <code>public</code> folder.</li> <li>Import custom SVGs as function components with <code>width</code> and <code>height</code> props.</li> <li>Internationalization (i18n):</li> <li>Add English values to <code>messages/en.json</code> using the format:     <code>Page/Component-Element/Sub-Component/Value</code>.<ul> <li>Example: For <code>&lt;button&gt;&lt;tag&gt;Text&lt;/tag&gt;&lt;/button&gt;</code> on the homepage, use: <code>\"HomePage/Button/tag: Text\"</code>.</li> </ul> </li> <li>Custom Hooks: Create hooks for reusable logic (e.g., modal handling).</li> <li>Rendering: Explicitly define client-side or server-side rendering for components.</li> </ul>"},{"location":"backend/","title":"Backend","text":""},{"location":"backend/#introduction","title":"Introduction","text":"<p>We use AdonisJS as a backend framework. AdonisJS is a Node.js framework that provides a lot of features to build a web application. You can see the documentation here.</p> <p>As the repository is a monorepo, the backend is in the <code>apps/backend</code> folder. We also use pnpm as a package manager. The main difference between pnpm and npm is that pnpm uses a single storage for all packages, so you can save a lot of disk space.</p>"},{"location":"backend/#setup","title":"Setup","text":"<p>In order to start using our project, the <code>.env</code> file must be set up! Use the <code>.env.example</code> file and complete it with the necessary keys (client keys, AWS keys...)</p> <p>To start the backend, you should have Node.js installed on your machine.</p> <p>Go to backend folder and install the web dependencies:</p> <pre><code>pnpm install\n</code></pre> <p>To build the project with the docker-compose at the root of the repository:</p> <pre><code>docker-compose up --build\n</code></pre> <p>Start the backend application (from the <code>apps/backend</code> folder): <pre><code>pnpm run dev\n</code></pre></p>"},{"location":"backend/#adonisjs","title":"AdonisJS","text":"<p>LibrOpen backend uses AdonisJS. So you can use directly AdonisJS features. Basically, the main command is</p> <pre><code>node ace\n</code></pre> <p>where you can see all commands</p> <p>You can see the AdonisJS documentation here</p>"},{"location":"backend/#route-and-query","title":"Route and query","text":"<p>If you want to create a new route, you should update the <code>route</code> file in the <code>start</code> folder.</p> <p>You should add your query in the <code>api</code> group, and you can create your own group for your root, for example if your queries should be in the path like <code>api/group_name/</code> so you can create <code>group_name</code> group.</p> <p>You can add some middleware, the basic middleware is the auth, where the user must be logged to execute this query.</p> <p>After this, you can create a Controller file, where you can add your code to execute your query.</p> <p>For this, I suggest you to see the AdonisJS documentation.</p>"},{"location":"frontend/","title":"Front-end","text":""},{"location":"frontend/#setup","title":"Setup","text":"<p>In order to start using our project, the <code>.env</code> file must be set up! Use the <code>.env.example</code> file and complete it with the necessary variables.</p> <p>Go to web-app folder and install the web dependencies:</p> <pre><code>pnpm install\n</code></pre> <p>Start the web application: <pre><code>pnpm run dev\n</code></pre></p>"},{"location":"infrastructure/","title":"Infrastructure","text":"<p>This document describes the infrastructure of the LibrOpen project.</p>"},{"location":"infrastructure/#overview","title":"Overview","text":"<p>The infrastructure of the LibrOpen project is based on the following components:</p> <ul> <li>GitHub: The main repository of the project is hosted on GitHub. The project uses GitHub Actions for continuous integration and deployment.</li> <li>Jenkins: The project uses Jenkins for continuous integration and deployment, the jenkins server is hosted on a virtual machine accessible with the following URL: http://jenkins.libropen.com.</li> <li>Docker: The project uses Docker for containerization. The Docker images are hosted on our own registry accessible with the following URL: https://registry.libropen.com.</li> <li>MiniIO: The project uses MiniIO for object storage. The MiniIO server is hosted on a virtual machine accessible with the following URL: http://minio.libropen.com.</li> <li>OpenVPN: To access the ressources of the infrastructure, you need to connect to the OpenVPN server hosted on a virtual machine accessible with a profile file provided by the team.</li> <li>Hoppscotch: The project uses Hoppscotch for API testing. The Hoppscotch server is hosted on a virtual machine accessible with the following URL: http://hoppscotch.libropen.com.</li> <li>Mail Server: The project uses a mail server to send emails to the users. The mail server is hosted on a virtual machine accessible with the following URL: http://mail.libropen.com/mail.</li> </ul>"},{"location":"infrastructure/#github","title":"GitHub","text":"<p>The main repository of the project is hosted on GitHub. The project uses GitHub Actions for continuous integration and deployment. The GitHub Actions are defined in the <code>.github/workflows</code> directory. The GitHub Actions are triggered on every push to the repository. There are two main workflows:</p> <ul> <li>backend.yml: This workflow is triggered on every push to the <code>backend</code> directory. It tries to build the backend application and run the tests and linter. It also pushes changes made by the linter to the git repository.</li> <li>frontend.yml: This workflow is triggered on every push to the <code>frontend</code> directory. It tries to build the frontend application and run the tests and linter. It also pushes changes made by the linter to the git repository</li> </ul>"},{"location":"infrastructure/#jenkins","title":"Jenkins","text":"<p>The project uses Jenkins for continuous integration and deployment. The jenkins server is hosted on a virtual machine accessible with the following URL: http://jenkins.libropen.com. The Jenkins server is configured to run the following jobs:</p> <ul> <li>Deployment: This job is triggered on every push to the <code>main</code> branch. It tries to build the backend and frontend applications and deploy them to the staging server. It also pushes the built docker images as artifact and to the self hosted docker registry.</li> </ul>"},{"location":"infrastructure/#docker","title":"Docker","text":"<p>The project uses Docker for containerization. The Docker images are hosted on our own registry accessible with the following URL: https://registry.libropen.com. The Docker images are built using the GitHub Actions and pushed to the registry.</p> <p>There is also a docker-compose file at the root of the repository that can be used to run the project locally. The docker-compose file defines the following services:</p> <ul> <li>postgres: The postgres database used by the backend application.</li> <li>frontend: The frontend application.</li> <li>backend: The backend application.</li> <li>backend_migration: The backend migration service, used to apply the database migrations.</li> <li>pgadmin: The pgadmin service, used to manage the postgres database using a web interface.</li> </ul> <p>There are also a network and a volume defined in the docker-compose file, used for file sharing and communication between the services.</p>"},{"location":"infrastructure/#miniio","title":"MiniIO","text":"<p>The project uses MiniIO for object storage. The MiniIO server is hosted on a virtual machine accessible with the following URL: http://minio.libropen.com. The MiniIO server is configured to use the following buckets:</p> <ul> <li>libropen: The main bucket used by the project to store files.</li> </ul>"},{"location":"infrastructure/#openvpn","title":"OpenVPN","text":"<p>To access the ressources of the infrastructure, you need to connect to the OpenVPN server hosted on a virtual machine accessible with a profile file provided by the team. If you don't use the profile file, the firewall will block all the incoming and outgoing traffic.</p>"},{"location":"infrastructure/#hoppscotch","title":"Hoppscotch","text":"<p>The project uses Hoppscotch for API testing. The Hoppscotch server is hosted on a virtual machine accessible with the following URL: http://hoppscotch.libropen.com. We use a shared workspace called 'LibrOpen' to share the API requests between the team members. If you want to join the workspace, please contact the team (admin@libropen.com).</p>"},{"location":"infrastructure/#mail-server","title":"Mail Server","text":"<p>The project uses a mail server to send emails to the users. The mail server is hosted on a virtual machine accessible with the following URL: http://mail.libropen.com/mail. The mail server is configured to use the following email addresses: teammembername@libropen.com For example if your name is John Doe, your email address will be john@libropen.com</p>"},{"location":"management/","title":"Project Management Guide","text":"<p>This document describes the steps and practices for project management within the team. It includes the breakdown of tasks, ticket creation, and sprint organization.</p>"},{"location":"management/#project-workflow","title":"Project Workflow","text":""},{"location":"management/#steps","title":"Steps","text":"<ol> <li>Define Objectives for a Feature (EPICs): Identify the main goal of a feature via an EPIC.</li> <li>Break Down EPIC into User Stories: Segment the EPIC into smaller functionalities expressed as User Stories.</li> <li>List User Stories on GitHub Projects: Create one or more tickets for each User Story.</li> <li>Explain and Assign Tickets: Add tickets to the backlog for the current or next sprint, with necessary details and assignments.</li> </ol>"},{"location":"management/#defining-epics","title":"Defining EPICs","text":"<p>EPICs represent the main features defined before starting the project or after team discussions.</p> <ul> <li>Purpose: EPICs guide the sprint\u2019s direction, aiming to complete them within one or two sprints of two weeks each.</li> <li>Example: An EPIC for creating a chat feature between users.</li> </ul> <p>Each EPIC is divided into smaller User Stories.</p>"},{"location":"management/#defining-user-stories","title":"Defining User Stories","text":"<p>User Stories are segments of an EPIC, representing small, user-centric functionalities.</p> <ul> <li>User-Centric Approach: Place yourself in the user\u2019s position to ensure a focus on user experience.</li> </ul> <p>Example for the chat EPIC:   - As a user, I can see a Chat page.</p> <ul> <li>Purpose: User Stories form the actionable tasks for developers.</li> <li>Completion: An EPIC is closed when all its User Stories are completed.</li> <li>Time Management:</li> <li>Assign an estimated time for each User Story.</li> <li>Track the actual time spent by developers.</li> <li>Use this data to compare estimated vs. actual time at the EPIC\u2019s conclusion.</li> </ul>"},{"location":"management/#creating-tickets","title":"Creating Tickets","text":"<p>After defining User Stories, translate them into tickets on GitHub Projects (Kanban).</p> <ul> <li>Placement: Add tickets to the backlog and name them based on their corresponding User Story.</li> <li>Sprint Start: At the beginning of a sprint linked to an EPIC, refine tickets by adding details:</li> <li>Technical steps</li> <li>Explanations if necessary</li> <li>Design screenshots if applicable</li> <li>Sprint priority</li> <li>Assignees if possible</li> <li>Estimated time</li> <li>Relevant stack labels (e.g., Frontend, Backend)</li> </ul>"},{"location":"management/#refining-tickets","title":"Refining Tickets","text":"<p>Tickets in the \"Backlog Refined\" column are discussed at the start of each sprint during the Monday team meeting.</p> <ul> <li>Purpose:</li> <li>Clarify ticket details.</li> <li>Assign tickets if team members volunteer.</li> </ul>"},{"location":"management/#group-management","title":"Group Management","text":""},{"location":"management/#weekly-meetings","title":"Weekly Meetings","text":"<p>Held every Monday at 5 PM (French time). Topics include:</p> <ol> <li>Review work from the past week.</li> <li>Plan tasks for the current week.</li> <li>Discuss current or upcoming sprint tickets (refinement).</li> <li>Address specific topics (e.g., design, tech, DevOps).</li> </ol>"},{"location":"management/#work-sessions","title":"Work Sessions","text":"<p>Collaborative work sessions are organized on:</p> <ul> <li>Weekends</li> <li>Wednesday or Thursday</li> </ul> <p>These sessions may involve voice calls for better coordination.</p>"}]}